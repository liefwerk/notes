<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Using Thunk</title>
</head><body><b>Using Thunk</b><br/>
<br/>
First, let's install <tt><span style="color: #00007f">redux-thunk<br/>
</span></tt><br/>
<tt><span style="color: #00007f">npm i redux-thunk</span></tt><br/>
<br/>
Then in the index.js file we import <b>Thunk</b><br/>
<br/>
<span style="color: #00007f"><tt>import thunk from 'redux-thunk'<br/>
<br/>
</tt></span>And we also import the method <span style="color: #00007f"><tt>applyMiddleware</tt></span>&nbsp;from redux, which will help us to setup Thunk<tt><span style="color: #00007f"><br/>
</span></tt><tt><span style="color: #00007f"><br/>
import { createStore, applyMiddleware } from 'redux'<br/>
</span></tt><br/>
The next step is to setup thunk inside that last imported method <tt><span style="color: #00007f">applyMiddleware()</span></tt><br/>
<br/>
<tt><span style="color: #00007f">const store = createStore(rootReducer, applyMiddleware(thunk));<br/>
<br/>
</span></tt><b>First project action<br/>
<br/>
</b>To initiate our first project action, we'll export a function that takes the project as a parameter.<br/>
That function will return another function that takes the dispatch and the state as parameters.<br/>
<br/>
Inside the dispatch function, we'll create the object with it's type and it's content.<b><br/>
</b><b><br/>
</b><tt><span style="color: #00007f">export const createProject = (project) =&gt; {<ul><li style="list-style-type: none">return (dispatch, getState) =&gt; {</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">// make async call to database</li>
</ul>
</li>
<li style="list-style-type: none">dispatch({ type: 'CREATE_PROJECT', project })</li>
<li style="list-style-type: none">}</li>
</ul>
}<br/>
<br/>
</span></tt>Once the createProject function is created, we import it in the components that will be allowed to modify the state. We'll be using the mapDispatchToProps function, it is constructed as follows:<br/>
<br/>
<span style="color: #00007f"><tt>const mapDispatchToProps = (dispatch) =&gt; {<br/>
&nbsp; return {</tt></span><tt><ul><li style="list-style-type: none"><span style="color: #007f7f">// it returns a createProject function that tales the project as a parameter, then uses the dispatch method to send the imported function with the project as a parameter</span><span style="color: #00007f"></span></li>
</ul>
<span style="color: #00007f">&nbsp; &nbsp; createProject: (project) =&gt; dispatch(createProject(project))<br/>
&nbsp; }<br/>
}<br/>
<br/>
</span><span style="color: #007f7f">// we pass null as the first parameter because we do not have a mapStateToProps() function to call</span><span style="color: #00007f"><br/>
</span><span style="color: #00007f">export default connect(null, mapDispatchToProps)(CreateProject)<br/>
<br/>
</span></tt>To call the function, we load it from the state<tt><span style="color: #00007f"><br/>
</span></tt><tt><span style="color: #00007f"><br/>
this.props.createProject(this.state)<br/>
<br/>
</span></tt>Then, that action is receives by a reducer and will return the state depending of the action type.<br/>
<br/>
<tt><span style="color: #00007f">const projectReducer = (state = initState, action) =&gt; {<ul><li style="list-style-type: none">switch (action.type){</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">case 'CREATE_PROJECT': </li>
</ul>
</li>
</ul>
<ul><ul><ul>console.log('project created', action.project);</ul>
</ul>
</ul>
&nbsp; &nbsp; <ul><li style="list-style-type: none">}</li>
<li style="list-style-type: none">return state</li>
</ul>
</span></tt><tt><span style="color: #00007f">}</span></tt><br/>
<br/>
</body></html>